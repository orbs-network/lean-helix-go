package test

// TODO incomplete

import (
	"bytes"
	lh "github.com/orbs-network/lean-helix-go"
	. "github.com/orbs-network/lean-helix-go/primitives"
	"github.com/orbs-network/lean-helix-go/test/builders"
	"github.com/stretchr/testify/require"
	"math"
	"math/rand"
	"strconv"
	"testing"
)

func TestPreparedMessagesExtractor(t *testing.T) {

	myStorage := lh.NewInMemoryStorage()
	//const logger: Logger = new SilentLogger();
	height := BlockHeight(math.Floor(rand.Float64() * 1000))
	view := View(math.Floor(rand.Float64() * 1000))
	block := builders.CreateBlock(builders.GenesisBlock)
	blockHash := builders.CalculateBlockHash(block)
	leaderId := Ed25519PublicKey(strconv.Itoa(int(math.Floor(rand.Float64() * 1000))))
	senderId1 := Ed25519PublicKey(strconv.Itoa(int(math.Floor(rand.Float64() * 1000))))
	senderId2 := Ed25519PublicKey(strconv.Itoa(int(math.Floor(rand.Float64() * 1000))))
	leaderKeyManager := builders.NewMockKeyManager(Ed25519PublicKey(leaderId))
	sender1KeyManager := builders.NewMockKeyManager(Ed25519PublicKey(senderId1))
	sender2KeyManager := builders.NewMockKeyManager(Ed25519PublicKey(senderId2))
	leaderMsgFactory := lh.NewMessageFactory(leaderKeyManager)
	sender1MsgFactory := lh.NewMessageFactory(sender1KeyManager)
	sender2MsgFactory := lh.NewMessageFactory(sender2KeyManager)

	ppm := leaderMsgFactory.CreatePreprepareMessage(height, view, block)
	pm1 := sender1MsgFactory.CreatePrepareMessage(height, view, blockHash)
	pm2 := sender2MsgFactory.CreatePrepareMessage(height, view, blockHash)
	//f := 1

	t.Run("should return the prepare proof", func(t *testing.T) {

		myStorage.StorePreprepare(ppm)
		myStorage.StorePrepare(pm1)
		myStorage.StorePrepare(pm2)

		expectedProof := &lh.PreparedMessages{
			PreprepareMessage: ppm,
			PrepareMessages:   []*lh.PrepareMessage{pm1, pm2},
		}

		actualProof := lh.ExtractPreparedMessages(height, myStorage, 1)
		require.True(t, bytes.Compare(expectedProof.PreprepareMessage.Raw(), actualProof.PreprepareMessage.Raw()) == 0)
		require.True(t, bytes.Compare(expectedProof.PrepareMessages[0].Raw(), actualProof.PrepareMessages[0].Raw()) == 0)
		require.True(t, bytes.Compare(expectedProof.PrepareMessages[1].Raw(), actualProof.PrepareMessages[1].Raw()) == 0)

	})

	t.Run("TestReturnPreparedProofWithHighestView", func(t *testing.T) {
		myStorage := lh.NewInMemoryStorage()
		ppm10 := leaderMsgFactory.CreatePreprepareMessage(1, 10, block)
		pm10a := sender1MsgFactory.CreatePrepareMessage(1, 10, blockHash)
		pm10b := sender2MsgFactory.CreatePrepareMessage(1, 10, blockHash)

		ppm20 := leaderMsgFactory.CreatePreprepareMessage(1, 20, block)
		pm20a := sender1MsgFactory.CreatePrepareMessage(1, 20, blockHash)
		pm20b := sender2MsgFactory.CreatePrepareMessage(1, 20, blockHash)

		ppm30 := leaderMsgFactory.CreatePreprepareMessage(1, 30, block)
		pm30a := sender1MsgFactory.CreatePrepareMessage(1, 30, blockHash)
		pm30b := sender2MsgFactory.CreatePrepareMessage(1, 30, blockHash)

		myStorage.StorePreprepare(ppm10)
		myStorage.StorePrepare(pm10a)
		myStorage.StorePrepare(pm10b)

		myStorage.StorePreprepare(ppm20)
		myStorage.StorePrepare(pm20a)
		myStorage.StorePrepare(pm20b)

		myStorage.StorePreprepare(ppm30)
		myStorage.StorePrepare(pm30a)
		myStorage.StorePrepare(pm30b)

		actualPPM, _ := myStorage.GetLatestPreprepare(1)
		require.Equal(t, actualPPM.View(), View(30), "View of preprepared message should be 30 (highest for this height)")
		//require.Equal(t, actualPPM.PrepareMessages()[0].SignedHeader().View(), View(30), "View of prepared message #1 should be 30 (highest for this height)")
		//require.Equal(t, actualPPM.PrepareMessages()[1].SignedHeader().View(), View(30), "View of prepared message #2 should be 30 (highest for this height)")
	})

	// TODO This "TestStoreAndGetPrepareProof" test will always PASS if "TestReturnPreparedProofWithHighestView" below passes, consider deleting
	//t.Run("TestStoreAndGetPrepareProof", func(t *testing.T) {
	//	myStorage := lh.NewInMemoryStorage()
	//	myStorage.StorePreprepare(ppm)
	//	myStorage.StorePrepare(pm2)
	//	myStorage.StorePrepare(pm1)
	//	expectedProof := lh.CreatePreparedProof(ppm, []lh.PrepareMessage{pm1, pm2})
	//
	//	actualProof, _ := myStorage.GetLatestPrepared(height, f)
	//	compPrepareProof(t, actualProof, expectedProof, "return a prepared proof generated by the PPM and PMs in storage")
	//})

	//t.Run("TestReturnNothingIfNoPrePrepare", func(t *testing.T) {
	//	myStorage := lh.NewInMemoryStorage()
	//	myStorage.StorePrepare(pm1)
	//	myStorage.StorePrepare(pm2)
	//	_, ok := myStorage.GetLatestPrepared(height, f)
	//	require.False(t, ok, "Don't return PreparedMessages from latest view if no PrePrepare in storage")
	//})
	//
	//t.Run("TestReturnNothingIfNoPrepares", func(t *testing.T) {
	//	myStorage := lh.NewInMemoryStorage()
	//	myStorage.StorePreprepare(ppm)
	//	_, ok := myStorage.GetLatestPrepared(height, f)
	//	require.False(t, ok, "Don't return PreparedMessages from latest view if no Prepare in storage")
	//})
	//
	//t.Run("TestReturnNothingIfNotEnoughPrepares", func(t *testing.T) {
	//	myStorage := lh.NewInMemoryStorage()
	//	myStorage.StorePreprepare(ppm)
	//	myStorage.StorePrepare(pm1)
	//	_, ok := myStorage.GetLatestPrepared(height, f)
	//	require.False(t, ok, "Don't return PreparedMessages from latest view if not enough Prepares in storage (# Prepares < 2*f)")
	//})
}

// TODO GetLatestPrepared() should initially be here as in TS code but later moved out, because it contains algo logic (it checks something with 2*f))
